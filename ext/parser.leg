%{

#include "ruby.h"
RUBY_GLOBAL_SETUP;

FILE *source_file;

int yy_input(char *buf, int max_size);

#define YY_INPUT(b, r, ms) (r = yy_input(b, ms))

#define YYSTYPE volatile VALUE

VALUE parser; /* ruby obj */
VALUE stack; /* ruby array */

#define SPUSH() \
  rb_ary_push(stack, rb_ary_new())

#define SADD(val) \
  rb_ary_push(rb_ary_entry(stack, RARRAY_LEN(stack) - 1), val)

#define SPOP() \
  rb_ary_pop(stack)

#define P_NEW(n, v)           rb_funcall(parser, rb_intern(n), 1, v)
#define P_NEW2(n, v1, v2)     rb_funcall(parser, rb_intern(n), 2, v1, v2)
#define P_NEW3(n, v1, v2, v3) rb_funcall(parser, rb_intern(n), 3, v1, v2, v3)
#define P_ADD(ast)            rb_funcall(parser, rb_intern("add"), 1, ast)

%}

body       = (
             e:lexpr                               { e && P_ADD(e); }
             )+ eof
           | lexpr* bad eof

bad        = < .+ >                                { P_ADD(P_NEW("syntax_error", rb_str_new(yytext, yyleng))); }

lexpr      = -* (
             empty-line
           | comment
           | icall
           | assign
           | expr
             ) -* --?

assign     = (name:identifier | name:symbol) -+
             "=" -+
             (val:icall | val:expr)                { $$ = P_NEW2("assign", name, val); }

icall      = name:identifier                       { SPUSH(); }
             (
             arg-sep arg:expr                      { SADD(arg); }
             )+                                    { $$ = P_NEW2("call", name, SPOP()); }

ecall      = "(" name:identifier                   { SPUSH(); }
             (
             arg-sep arg:expr                      { SADD(arg); }
             )* ")"                                { $$ = P_NEW2("call", name, SPOP()); }

arg-sep    = "," (- | --)* | -+

expr       = op
           | eop
           | ecall
           | func
           | list
           | atom

func       = args:func-args
             "{" (- | --)*                         { SPUSH(); }
             (
             e:lexpr                               { e && SADD(e); }
             )+
             -* "}"                                { $$ = P_NEW2("func", args ? args : rb_ary_new(), SPOP()); }

func-args  = "["                                   { SPUSH(); }
             ( -*
             arg:identifier                        { SADD(arg); }
             )+ -*
             "]" -*                                { $$ = SPOP(); }
           | &"{"                                  { $$ = 0; }

op         = left:operand -+
             symbol:symbol -+
             right:operand                         { $$ = P_NEW3("op", symbol, left, right); }

eop        = "(" op ")"

operand    = list
           | atom
           | eop
           | ecall

atom       = var
           | str:string                            { $$ = P_NEW("string", str); }
           | range
           | integer

list       = "[" -*                                { SPUSH(); }
             (
             e:expr (- | --)*                      { SADD(e); }
             )*
             "]"                                   { $$ = P_NEW("list", SPOP()); }

rangeop    = var
           | integer
           | eop
           | ecall

range      = first:rangeop ".." last:rangeop       { $$ = P_NEW2("range", first, last); }

var        = name:identifier                       { $$ = P_NEW("var", name); }

dq         = "\""
sq         = "\'"
ndq        = !dq .
nsq        = !sq .
esc        = "\\" .
string     = dq < (esc | ndq)* > dq                { $$ = rb_str_new(yytext, yyleng); }
           | sq < (esc | nsq)* > sq                { $$ = rb_str_new(yytext, yyleng); }

empty-line = -* --                                 { $$ = 0; }
comment    = -* '#' [^\r\n]* --?                   { $$ = 0; }

symbol     = < [-~`!?@$%^&*_+|/,.<>]+ >            { $$ = rb_str_new(yytext, yyleng); }
           | < [-~`!?@$%^&*_+|/,.<>=]
               [-~`!?@$%^&*_+|/,.<>=]+ >           { $$ = rb_str_new(yytext, yyleng); }

identifier = < [a-z] [a-z0-9-]* >                  { $$ = rb_str_new(yytext, yyleng); }

integer    = < digit+ >                            { $$ = P_NEW("integer", rb_str_new(yytext, yyleng)); }

digit      = [0-9]

-          = [ \t]
--         = [\r]? [\n]
eof        = !.

%%

/* borrowed from O'Reilly book "lex & yacc" pg. 157 */
char *yy_input_ptr;
int yy_input_len;

int yy_input(char *buf, int max_size) {
  int len = strlen(yy_input_ptr);
  int n = max_size < len ? max_size : len;
  if(n > 0) {
    memcpy(buf, yy_input_ptr, n);
    yy_input_ptr += n;
  }
  return n;
}

static VALUE rb_cParser_parse(VALUE self, VALUE source) {
  VALUE rb_cGC = rb_const_get(rb_cObject, rb_intern("GC"));
  rb_funcall(rb_cGC, rb_intern("disable"), 0, 0);
  yy_input_ptr = rb_string_value_cstr(&source);
  yy_input_len = strlen(yy_input_ptr);
  stack = rb_ary_new();
  parser = self;
  rb_iv_set(self, "@expressions", rb_ary_new());
  while (yyparse());
  rb_funcall(rb_cGC, rb_intern("enable"), 0, 0);
  return rb_iv_get(self, "@expressions");
}

void Init_parser() {
  VALUE rb_mAirball = rb_const_get(rb_cObject, rb_intern("Airball"));
  VALUE rb_cParser = rb_const_get(rb_mAirball, rb_intern("Parser"));
  rb_define_method(rb_cParser, "parse", rb_cParser_parse, 1);
  rb_gc_register_address(&stack);
}
