%{

#include <string.h>
#include <glib.h>

int yy_input(char *buf, int max_size);

#define YY_INPUT(b, r, ms) (r = yy_input(b, ms))

#define YYSTYPE node*

GSList* parse_ast;

#define SPUSH() \
  printf("noop\n")

#define SADD(val) \
  printf("noop\n")

#define SPOP() \
  printf("noop\n")

#define P_NEW(n, v)           malloc(sizeof(node*))
#define P_NEW2(n, v1, v2)     malloc(sizeof(node*))
#define P_NEW3(n, v1, v2, v3) malloc(sizeof(node*))
#define P_ADD(node)           (parse_ast = g_slist_append(parse_ast, node))

node* rb_str_new(char *, int);
node* rb_ary_new();

char* yytos(char *, int);

node* create_int_node(char*, int);
node* create_str_node(char*, int);
node* create_rng_node(node*, node*);
node* create_var_node(char*);
node* create_err_node(char*, int);

%}

body       = (
             e:lexpr                               { e && P_ADD(e); }
             )+ eof
           | lexpr* bad eof

bad        = < .+ >                                { P_ADD(create_err_node(yytext, yyleng)); }

lexpr      = -* (
             empty-line
           | comment
           | icall
           | assign
           | expr
             ) -* --?

assign     = (name:identifier | name:symbol) -+
             "=" -+
             (val:icall | val:expr)                { $$ = P_NEW2("assign", name, val); }

icall      = name:identifier                       { SPUSH(); }
             (
             arg-sep arg:expr                      { SADD(arg); }
             )+                                    { $$ = P_NEW2("call", name, SPOP()); }

ecall      = "(" name:identifier                   { SPUSH(); }
             (
             arg-sep arg:expr                      { SADD(arg); }
             )* ")"                                { $$ = P_NEW2("call", name, SPOP()); }

arg-sep    = "," (- | --)* | -+

expr       = op
           | eop
           | ecall
           | func
           | list
           | atom

func       = args:func-args
             "{" (- | --)*                         { SPUSH(); }
             (
             e:lexpr                               { e && SADD(e); }
             )+
             -* "}"                                { $$ = P_NEW2("func", args ? args : rb_ary_new(), SPOP()); }

func-args  = "["                                   { SPUSH(); }
             ( -*
             arg:identifier                        { SADD(arg); }
             )+ -*
             "]" -*                                { $$ = SPOP(); }
           | &"{"                                  { $$ = 0; }

op         = left:operand -+
             symbol:symbol -+
             right:operand                         { $$ = P_NEW3("op", symbol, left, right); }

eop        = "(" op ")"

operand    = list
           | atom
           | eop
           | ecall

atom       = var
           | string
           | range
           | integer

list-sep   = - | -- | ","

list       = "[" -*                                { SPUSH(); }
             (
             e:expr list-sep*                      { SADD(e); }
             )*
             "]"                                   { $$ = P_NEW("list", SPOP()); }

rangeop    = var
           | integer
           | eop
           | ecall

range      = first:rangeop ".." last:rangeop       { $$ = create_rng_node(first, last); }

var        = name:identifier                       { $$ = create_var_node(name); }

dq         = "\""
sq         = "\'"
ndq        = !dq .
nsq        = !sq .
esc        = "\\" .
string     = dq < (esc | ndq)* > dq                { $$ = create_str_node(yytext, yyleng); }
           | sq < (esc | nsq)* > sq                { $$ = create_str_node(yytext, yyleng); }

empty-line = -* --                                 { $$ = 0; }
comment    = -* '#' [^\r\n]* --?                   { $$ = 0; }

symbol     = < [-~`!?@$%^&*_+|/,.<>]+ >            { $$ = rb_str_new(yytext, yyleng); }
           | < [-~`!?@$%^&*_+|/,.<>=]
               [-~`!?@$%^&*_+|/,.<>=]+ >           { $$ = rb_str_new(yytext, yyleng); }

identifier = < [a-z] [a-z0-9-]* >                  { $$ = yytos(yytext, yyleng); }

integer    = < digit+ >                            { $$ = create_int_node(yytext, yyleng); }

digit      = [0-9]

-          = [ \t]
--         = [\r]? [\n]
eof        = !.

%%

/* borrowed from O'Reilly book "lex & yacc" pg. 157 */
char *yy_input_ptr;
int yy_input_len;

node* rb_str_new(char * text, int length) {
  printf("noop\n");
  return (node*)malloc(sizeof(node*));
}

node* rb_ary_new() {
  printf("noop\n");
  return (node*)malloc(sizeof(node*));
}

char* yytos(char* yytext, int yyleng) {
  char* s = malloc(sizeof(char) * (yyleng + 1));
  strcpy(s, "");
  strncat(s, yytext, yyleng);
  return s;
}

node* create_int_node(char* yytext, int yyleng) {
  node* n = malloc(sizeof(node*));
  n->type = INT_TYPE;
  n->value.i = atoi(yytext);
  return n;
}

node* create_str_node(char* yytext, int yyleng) {
  node* n = malloc(sizeof(node*));
  n->type = STR_TYPE;
  n->value.s = malloc(sizeof(char) * (yyleng + 1));
  strcpy(n->value.s, "");
  strncat(n->value.s, yytext, yyleng);
  return n;
}

node* create_rng_node(node* first, node* last) {
  node* n = malloc(sizeof(node*));
  n->type = RNG_TYPE;
  n->value.r = malloc(sizeof(struct range));
  n->value.r->first = first;
  n->value.r->last = last;
  return n;
}

node* create_var_node(char* name) {
  node* n = malloc(sizeof(node*));
  n->type = VAR_TYPE;
  n->value.v = malloc(sizeof(struct var));
  n->value.v->name = name;
  return n;
}

node* create_err_node(char* yytext, int yyleng) {
  node* n = malloc(sizeof(node*));
  n->type = ERR_TYPE;
  n->value.e = malloc(sizeof(char) * (yyleng + 1));
  strcpy(n->value.e, "");
  strncat(n->value.e, yytext, yyleng);
  return n;
}

int yy_input(char *buf, int max_size) {
  int len = strlen(yy_input_ptr);
  int n = max_size < len ? max_size : len;
  if(n > 0) {
    memcpy(buf, yy_input_ptr, n);
    yy_input_ptr += n;
  }
  return n;
}

GSList* airball_parse(char *source) {
  parse_ast = NULL;
  yy_input_ptr = source;
  yy_input_len = strlen(yy_input_ptr);
  while (yyparse());
  return parse_ast;
}
